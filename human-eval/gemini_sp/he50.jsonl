{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str):\n    \"\"\"\n    Returns encoded string by shifting every lowercase character by 5 in the alphabet.\n    \n    The encoding process:\n    1. Get the ASCII value of the character (ord(ch)).\n    2. Subtract ord('a') to get a 0-indexed position (0-25).\n    3. Add 5 for the forward shift.\n    4. Apply modulo 26 for wrap-around (z -> e).\n    5. Add ord('a') back to convert the position back to the character's ASCII code.\n    \"\"\"\n    # Note: This implementation assumes the input 's' contains only lowercase 'a'-'z'.\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    Takes as input a string encoded with the encode_shift function (a +5 Caesar cipher). \n    Returns the original decoded string by applying an inverse -5 shift.\n    \n    The decoding process applies the inverse modular arithmetic:\n    1. Convert the character to its 0-indexed position (ord(ch) - ord('a')).\n    2. Subtract the shift amount (5).\n    3. Apply modulo 26 to ensure proper wrap-around for negative results \n       (e.g., 'e' -> 'z' is handled by -1 % 26 == 25 in Python).\n    4. Add ord('a') back to get the ASCII value of the original character.\n    5. Convert the ASCII value back to a character (chr()).\n    \"\"\"\n    \n    # We use a list comprehension for efficient, one-line iteration and transformation.\n    return \"\".join([\n        chr(((ord(ch) - ord(\"a\") - 5) % 26) + ord(\"a\")) \n        for ch in s\n    ])"}
