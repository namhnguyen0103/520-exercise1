{"task_id": "HumanEval/80", "completion": "from typing import Iterable\n\ndef is_happy(s: str) -> bool:\n    \"\"\"\n    Determine whether a string is \"happy\".\n\n    A string is happy iff:\n      1) Its length is at least 3, and\n      2) For every contiguous triple of characters (s[i], s[i+1], s[i+2]),\n         all three characters are pairwise distinct.\n\n    The check is purely by character equality; it works for ASCII and Unicode.\n\n    Examples\n    --------\n    >>> is_happy(\"a\")\n    False\n    >>> is_happy(\"aa\")\n    False\n    >>> is_happy(\"abcd\")\n    True\n    >>> is_happy(\"aabb\")\n    False\n    >>> is_happy(\"adb\")\n    True\n    >>> is_happy(\"xyy\")\n    False\n    >>> is_happy(\"abca\")  # \"abc\" and \"bca\" are both triples of distinct chars\n    True\n    \"\"\"\n    # 1) Early exit for strings shorter than 3 characters.\n    if len(s) < 3:\n        return False\n\n    # 2) Slide a window of size 3 across the string.\n    #    For each window (a, b, c), ensure pairwise distinctness.\n    #    We use direct comparisons for O(1) space and speed.\n    #    Equivalent to: len({a, b, c}) == 3, but avoids set allocation.\n    for i in range(len(s) - 2):\n        a, b, c = s[i], s[i + 1], s[i + 2]\n        if not (a != b and a != c and b != c):\n            # Found a triple with a repeated character -> not happy.\n            return False\n\n    # 3) All triples were distinct -> happy string.\n    return True\n\n\n# Optional lightweight self-checks (not executed unless run as a script).\nif __name__ == \"__main__\":\n    tests: Iterable[tuple[str, bool]] = [\n        (\"\", False),\n        (\"a\", False),\n        (\"aa\", False),\n        (\"adb\", True),\n        (\"abc\", True),\n        (\"abcd\", True),\n        (\"aabb\", False),\n        (\"xyy\", False),\n        (\"xxy\", False),\n        (\"xxx\", False),\n        (\"abca\", True),\n        (\"a\ud83d\ude0ab\", True),  # Unicode works the same way\n        (\"a a\", False),  # contains a space; still just chars\n    ]\n    for s, expected in tests:\n        got = is_happy(s)\n        assert got == expected, f\"is_happy({s!r}) -> {got}, expected {expected}\""}
