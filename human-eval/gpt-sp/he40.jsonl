{"task_id": "HumanEval/40", "completion": "from typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    Return True iff there exist three distinct elements in the list whose sum is zero.\n\n    This implementation follows the classic \"sort + two-pointer\" 3-sum pattern:\n    - Sort the array (enables pruning and two-pointer sweeps)\n    - Fix one value a[i], then scan the remaining range with two pointers (left, right)\n    - Early-exit on the first valid triple; otherwise return False after exhaustion\n\n    The indices i < left < right are always distinct, so distinctness is guaranteed.\n\n    Args:\n        l: List of integers (may contain negatives, zeros, positives, and duplicates).\n\n    Returns:\n        True if a triple summing to zero exists; False otherwise.\n\n    Complexity:\n        Time  : O(n^2) in the worst case (sorting is O(n log n), dominated by the scan).\n        Space : O(n) due to making a sorted copy (keeps the input list unmodified).\n\n    Examples (doctests):\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    >>> triples_sum_to_zero([0, 0, 0])\n    True\n    >>> triples_sum_to_zero([-1, -1, 2])\n    True\n    \"\"\"\n\n    # Fast-fail: fewer than 3 items cannot form a triple.\n    if len(l) < 3:\n        return False\n\n    # Use a *copy* to avoid mutating the caller's list.\n    a = sorted(l)\n    n = len(a)\n\n    # Iterate each index as the fixed element of the triple.\n    for i in range(n - 2):\n        x = a[i]\n\n        # Pruning: if the fixed value is > 0, all following values are >= x (sorted),\n        # so any sum x + ... + ... will be > 0 and cannot reach 0.\n        if x > 0:\n            return False\n\n        # Optional optimization: skip duplicate fixed values to reduce redundant scans.\n        if i > 0 and a[i] == a[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n        while left < right:\n            s = x + a[left] + a[right]\n            if s == 0:\n                # Found a valid triple; existence is sufficient.\n                return True\n            if s < 0:\n                # Sum too small; move left forward to increase the total.\n                left += 1\n                # Optional duplicate-skip on the left pointer.\n                while left < right and a[left] == a[left - 1]:\n                    left += 1\n            else:\n                # s > 0: Sum too large; move right backward to decrease the total.\n                right -= 1\n                # Optional duplicate-skip on the right pointer.\n                while left < right and a[right] == a[right + 1]:\n                    right -= 1\n\n    # Exhausted all candidates without finding any triple.\n    return False"}
