{"task_id": "HumanEval/100", "completion": "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Build a list of stone counts for a pile with `n` levels.\n\n    The first level has `n` stones. Each subsequent level increases by 2, which\n    preserves the parity of `n` (odd stays odd, even stays even). This forms an\n    arithmetic progression of length `n`, first term `n`, common difference `2`.\n\n    Parameters\n    ----------\n    n : int\n        Positive integer (>= 1) specifying both the first level size and the\n        number of levels.\n\n    Returns\n    -------\n    List[int]\n        A list `levels` where levels[i] = n + 2*i for i in [0, n-1].\n\n    Raises\n    ------\n    TypeError\n        If `n` is not an integer.\n    ValueError\n        If `n` < 1.\n\n    Examples\n    --------\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(4)\n    [4, 6, 8, 10]\n    >>> make_a_pile(1)\n    [1]\n    \"\"\"\n    # --- Input validation (strict policy) ---\n    # Ensure the type is exactly int (no silent coercion). This avoids surprises\n    # like floats being truncated and keeps API behavior explicit and predictable.\n    if not isinstance(n, int):\n        raise TypeError(f\"n must be an int, got {type(n).__name__}\")\n    if n < 1:\n        raise ValueError(\"n must be >= 1\")\n\n    # --- Sequence generation ---\n    # This is an arithmetic progression of length n:\n    # term_i (0-indexed) = n + 2*i\n    # Complexity: O(n) time, O(n) space.\n    levels = [n + 2 * i for i in range(n)]\n\n    # --- Return result ---\n    return levels\n\n\nif __name__ == \"__main__\":\n    # Lightweight self-checks and doctest hook for quick verification.\n    import doctest\n    doctest.testmod()\n\n    # Property-style checks\n    for k in (1, 2, 3, 6, 10):\n        seq = make_a_pile(k)\n        # Length equals n\n        assert len(seq) == k\n        # First term equals n\n        assert seq[0] == k\n        # Constant difference of 2\n        assert all(b - a == 2 for a, b in zip(seq, seq[1:]))\n        # Parity preserved\n        assert all(x % 2 == k % 2 for x in seq)\n\n    # Negative tests (should raise)\n    try:\n        make_a_pile(0)\n    except ValueError:\n        pass\n    else:\n        raise AssertionError(\"Expected ValueError for n=0\")\n\n    try:\n        make_a_pile(2.5)  # type: ignore[arg-type]\n    except TypeError:\n        pass\n    else:\n        raise AssertionError(\"Expected TypeError for n=2.5\")"}
