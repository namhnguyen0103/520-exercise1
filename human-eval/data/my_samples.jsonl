{"task_id": "HumanEval/100", "completion": "def make_a_pile(n: int) -> list[int]:\n    \"\"\"\n    Return a list of length n where the i-th element (1-indexed) is n + 2*(i-1).\n    This creates n levels starting at n and increasing by 2 each time (parity preserved).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(4)\n    [4, 6, 8, 10]\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return [n + 2 * i for i in range(n)]"}
{"task_id": "HumanEval/100", "completion": "from typing import List\n\ndef make_a_pile(n: int) -> List[int]:\n    \"\"\"\n    Build a list of stone counts for a pile with `n` levels.\n\n    The first level has `n` stones. Each subsequent level increases by 2, which\n    preserves the parity of `n` (odd stays odd, even stays even). This forms an\n    arithmetic progression of length `n`, first term `n`, common difference `2`.\n\n    Parameters\n    ----------\n    n : int\n        Positive integer (>= 1) specifying both the first level size and the\n        number of levels.\n\n    Returns\n    -------\n    List[int]\n        A list `levels` where levels[i] = n + 2*i for i in [0, n-1].\n\n    Raises\n    ------\n    TypeError\n        If `n` is not an integer.\n    ValueError\n        If `n` < 1.\n\n    Examples\n    --------\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(4)\n    [4, 6, 8, 10]\n    >>> make_a_pile(1)\n    [1]\n    \"\"\"\n    # --- Input validation (strict policy) ---\n    # Ensure the type is exactly int (no silent coercion). This avoids surprises\n    # like floats being truncated and keeps API behavior explicit and predictable.\n    if not isinstance(n, int):\n        raise TypeError(f\"n must be an int, got {type(n).__name__}\")\n    if n < 1:\n        raise ValueError(\"n must be >= 1\")\n\n    # --- Sequence generation ---\n    # This is an arithmetic progression of length n:\n    # term_i (0-indexed) = n + 2*i\n    # Complexity: O(n) time, O(n) space.\n    levels = [n + 2 * i for i in range(n)]\n\n    # --- Return result ---\n    return levels\n\n\nif __name__ == \"__main__\":\n    # Lightweight self-checks and doctest hook for quick verification.\n    import doctest\n    doctest.testmod()\n\n    # Property-style checks\n    for k in (1, 2, 3, 6, 10):\n        seq = make_a_pile(k)\n        # Length equals n\n        assert len(seq) == k\n        # First term equals n\n        assert seq[0] == k\n        # Constant difference of 2\n        assert all(b - a == 2 for a, b in zip(seq, seq[1:]))\n        # Parity preserved\n        assert all(x % 2 == k % 2 for x in seq)\n\n    # Negative tests (should raise)\n    try:\n        make_a_pile(0)\n    except ValueError:\n        pass\n    else:\n        raise AssertionError(\"Expected ValueError for n=0\")\n\n    try:\n        make_a_pile(2.5)  # type: ignore[arg-type]\n    except TypeError:\n        pass\n    else:\n        raise AssertionError(\"Expected TypeError for n=2.5\")"}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n    \"\"\"\n    \n    # 1. Initialize the list with the number of stones in the first level, which is n.\n    pile = [n]\n    \n    # 2. Start the current stone count with the first level's count.\n    current_stones = n\n    \n    # 3. Iterate n-1 times to generate the remaining levels.\n    # The total number of levels is n, so we need n-1 more levels after the first one.\n    for _ in range(n - 1):\n        # 4. In each iteration, the next level has 2 more stones than the previous.\n        current_stones += 2\n        \n        # 5. Append the new stone count to the pile list.\n        pile.append(current_stones)\n        \n    return pile\n\n# Examples:\n# print(make_a_pile(3))  # Expected: [3, 5, 7]\n# print(make_a_pile(4))  # Expected: [4, 6, 8, 10]\n# print(make_a_pile(1))  # Expected: [1]"}
{"task_id": "HumanEval/100", "completion": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, this function calculates the number of stones \n    in each of the n levels of a stone pile.\n\n    The rules for the number of stones in each subsequent level are:\n    1. The first level has n stones.\n    2. Subsequent levels increase by 2 (next odd or next even number), \n       maintaining the parity of n.\n\n    Args:\n        n (int): The number of levels in the pile (must be a positive integer).\n\n    Returns:\n        list[int]: A list where each element is the number of stones in the \n                   corresponding level, from level 1 to level n.\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(4)\n    [4, 6, 8, 10]\n    \"\"\"\n    # 1. Function Definition and Initialization\n    # Initialize an empty list to store the number of stones in each level.\n    pile_stones = []\n\n    # Check if n is a positive integer, although the prompt implies valid input.\n    if n <= 0:\n        # Returning an empty list for non-positive inputs\n        return pile_stones\n\n    # 2. Base Case and Iteration Setup\n    # The first level (Level 1) always has 'n' stones.\n    current_stones = n\n    pile_stones.append(current_stones)\n\n    # The rule is that the next level's stone count must maintain the parity \n    # of 'n' while being the next number of that parity. Since the difference \n    # between consecutive odd numbers is 2, and the difference between \n    # consecutive even numbers is also 2, the number of stones always increases \n    # by 2, regardless of n's initial parity.\n\n    # 3. Iterative Calculation of Subsequent Levels\n    # We need to calculate stones for the remaining n-1 levels (from level 2 to n).\n    # The loop runs for i = 1, 2, ..., n-1 times.\n    for i in range(1, n):\n        # Determine the number of stones for the next level.\n        # Since the parity is already established by 'n', and we always need the \n        # *next* number of that same parity, we simply add 2 to the previous level's count.\n        \n        # Case 1: n is Odd (e.g., 3 -> 5 -> 7)\n        # Case 2: n is Even (e.g., 4 -> 6 -> 8)\n        # In both cases, the increment is +2.\n        next_stones = current_stones + 2\n        \n        # Update the list with the calculated stone count.\n        pile_stones.append(next_stones)\n        \n        # Update the working variable for the next iteration.\n        current_stones = next_stones\n\n    # 4. Return Value\n    return pile_stones"}
{"task_id": "HumanEval/90", "completion": "from math import inf\nfrom typing import List, Optional\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    \"\"\"\n    Return the 2nd smallest *distinct* element of lst.\n    Return None if it does not exist.\n    Examples:\n        next_smallest([1, 2, 3, 4, 5]) == 2\n        next_smallest([5, 1, 4, 3, 2]) == 2\n        next_smallest([]) == None\n        next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    m1, m2 = inf, inf  # m1 = smallest, m2 = second-smallest distinct\n\n    for x in lst:\n        if x < m1:\n            m1, m2 = x, m1\n        elif m1 < x < m2:\n            m2 = x\n        # else: x == m1 or x >= m2 \u2192 no update\n\n    return None if m2 is inf else m2\n\n\n# Quick self-checks\nif __name__ == \"__main__\":\n    assert next_smallest([1, 2, 3, 4, 5]) == 2\n    assert next_smallest([5, 1, 4, 3, 2]) == 2\n    assert next_smallest([]) is None\n    assert next_smallest([1, 1]) is None\n    assert next_smallest([2, 2, 3]) == 3\n    assert next_smallest([7, 7, 7, 7]) is None"}
{"task_id": "HumanEval/90", "completion": "from typing import Iterable, Optional\nimport math\n\ndef next_smallest(lst: Iterable[int]) -> Optional[int]:\n    \"\"\"\n    Return the second smallest *distinct* integer in `lst`.\n    If there is no such element (e.g., list too short or all values equal), return None.\n\n    The function does not mutate `lst` and operates in a single pass with O(1) extra space.\n\n    Definitions:\n    - Let `m1` be the smallest distinct value.\n    - Let `m2` be the smallest distinct value strictly greater than `m1`.\n    - Return `m2` if it exists; else return None.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    >>> next_smallest([1, 1])\n    >>> next_smallest([2, 2, 3])\n    3\n    >>> next_smallest([-1, -5, -5, -2])\n    -2\n\n    Complexity:\n    - Time: O(n) for n = len(lst), single pass\n    - Space: O(1) auxiliary\n    \"\"\"\n\n    # Sentinels representing +\u221e to initialize the two minima.\n    # Using float('inf') keeps comparisons valid against ints in Python.\n    first = math.inf   # smallest distinct value seen so far\n    second = math.inf  # second smallest distinct value (> first)\n\n    # Iterate once and maintain the two minima with strict ordering.\n    for x in lst:\n        # If type robustness is desired, uncomment:\n        # if not isinstance(x, int):\n        #     raise TypeError(f\"All elements must be int, got {type(x).__name__}\")\n\n        if x < first:\n            # New global minimum found: demote previous `first` to `second`\n            second = first\n            first = x\n        elif first < x < second:\n            # x is strictly greater than `first` but smaller than current `second`\n            second = x\n        # else: ignore (covers x == first and x >= second)\n\n    # If `second` was never updated to a finite number, no valid second minimum exists.\n    return None if second is math.inf else int(second)\n\n\n# ---------------------------\n# Basic self-checks (optional)\n# ---------------------------\nif __name__ == \"__main__\":\n    tests = [\n        ([1, 2, 3, 4, 5], 2),\n        ([5, 1, 4, 3, 2], 2),\n        ([], None),\n        ([1, 1], None),\n        ([2], None),\n        ([2, 2, 3], 3),\n        ([3, 2, 2], 3),\n        ([2, 3, 2, 4, 4, 5], 3),\n        ([-1, -5, -5, -2], -2),\n        ([7, 7, 7, 7], None),\n        ([0, 1], 1),\n        ([-10, -10, -9], -9),\n        ([5, 1, 1, 1], 5),\n    ]\n\n    for arr, expected in tests:\n        result = next_smallest(arr)\n        assert result == expected, f\"next_smallest({arr}) -> {result}, expected {expected}\"\n    print(\"All tests passed.\")"}
{"task_id": "HumanEval/90", "completion": "def next_smallest(lst):\n    \"\"\"\n    Given a list of integers, this function returns the 2nd smallest unique\n    element of the list.\n    Returns None if there are fewer than two unique elements.\n    \"\"\"\n    # Step 1: Convert to a set to efficiently find all unique elements.\n    unique_elements = set(lst)\n\n    # Step 2: Convert the unique set back to a list and sort it in ascending order.\n    # This places the smallest unique element at index 0, and the second smallest at index 1.\n    unique_sorted = sorted(list(unique_elements))\n\n    # Step 3: Check if there are at least two unique elements.\n    # If the length is 0 (empty list) or 1 (e.g., [1] or [1, 1]), return None.\n    if len(unique_sorted) < 2:\n        return None\n    else:\n        # Step 4: The second smallest unique element is at index 1.\n        return unique_sorted[1]\n\n# Example usage and tests (as requested in the prompt)\n# print(f\"Test 1: [1, 2, 3, 4, 5] -> {next_smallest([1, 2, 3, 4, 5])}\")\n# print(f\"Test 2: [5, 1, 4, 3, 2] -> {next_smallest([5, 1, 4, 3, 2])}\")\n# print(f\"Test 3: [] -> {next_smallest([])}\")\n# print(f\"Test 4: [1, 1] -> {next_smallest([1, 1])}\")\n# print(f\"Test 5: [2, 1, 1, 3] -> {next_smallest([2, 1, 1, 3])}\") # Should be 2\n# print(f\"Test 6: [100] -> {next_smallest([100])}\") # Should be None"}
{"task_id": "HumanEval/90", "completion": "import collections\n\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest unique element of the list.\n    Returns None if there is no such element (i.e., less than two unique elements).\n\n    Args:\n        lst (list[int]): The input list of integers.\n\n    Returns:\n        int | None: The second smallest unique element, or None if not found.\n    \"\"\"\n    # Phase 1: Data Pre-processing and Deduplication\n    # Convert the list to a set to efficiently eliminate all duplicate elements.\n    unique_elements_set = set(lst)\n\n    # Convert the set back to a list. This step is necessary as sets are unordered\n    # and do not support indexing required for the sorting and selection phase.\n    unique_elements = list(unique_elements_set)\n\n    # Phase 2: Edge Case Validation\n    # Check if there are at least two unique elements remaining.\n    # If the length is 0 (empty list), 1 (e.g., [5]), or 1 (e.g., [1, 1, 1]),\n    # there is no \"second smallest unique\" element.\n    if len(unique_elements) < 2:\n        return None\n\n    # Phase 3: Sorting and Element Selection\n    # Sort the list of unique elements in ascending order.\n    # This places the smallest element at index 0 and the second smallest at index 1.\n    unique_elements.sort()\n\n    # Access the element at index 1, which represents the second smallest unique value.\n    second_smallest = unique_elements[1]\n\n    # Phase 4: Final Output\n    return second_smallest\n\n# --- Example Usage and Verification ---\n\n# Example 1: Standard case\nprint(f\"next_smallest([1, 2, 3, 4, 5]) -> {next_smallest([1, 2, 3, 4, 5])}\")\n# Expected: 2\n\n# Example 2: Unsorted case with duplicates\nprint(f\"next_smallest([5, 1, 4, 3, 2, 3, 4, 5]) -> {next_smallest([5, 1, 4, 3, 2, 3, 4, 5])}\")\n# Expected: 2 (Unique elements: [1, 2, 3, 4, 5])\n\n# Example 3: Empty list (Edge Case)\nprint(f\"next_smallest([]) -> {next_smallest([])}\")\n# Expected: None\n\n# Example 4: List with only one unique element (Edge Case)\nprint(f\"next_smallest([1, 1]) -> {next_smallest([1, 1])}\")\n# Expected: None\n\n# Example 5: List with negative numbers\nprint(f\"next_smallest([-5, -1, -4, -3, -2]) -> {next_smallest([-5, -1, -4, -3, -2])}\")\n# Expected: -4 (Unique and sorted: [-5, -4, -3, -2, -1]. Index 1 is -4)\n\n# Example 6: Two unique elements\nprint(f\"next_smallest([10, 20, 10]) -> {next_smallest([10, 20, 10])}\")\n# Expected: 20"}
{"task_id": "HumanEval/80", "completion": "def is_happy(s: str) -> bool:\n    \"\"\"\n    A string is 'happy' if its length is at least 3 and\n    every group of 3 consecutive characters are all distinct.\n\n    Examples:\n    >>> is_happy(\"a\")\n    False\n    >>> is_happy(\"aa\")\n    False\n    >>> is_happy(\"abcd\")\n    True\n    >>> is_happy(\"aabb\")\n    False\n    >>> is_happy(\"adb\")\n    True\n    >>> is_happy(\"xyy\")\n    False\n    \"\"\"\n    # Must have at least 3 characters to form a triple\n    if len(s) < 3:\n        return False\n\n    # Check each consecutive triple for distinctness\n    for i in range(len(s) - 2):\n        a, b, c = s[i], s[i + 1], s[i + 2]\n        if len({a, b, c}) != 3:\n            return False\n\n    return True"}
{"task_id": "HumanEval/80", "completion": "from typing import Iterable\n\ndef is_happy(s: str) -> bool:\n    \"\"\"\n    Determine whether a string is \"happy\".\n\n    A string is happy iff:\n      1) Its length is at least 3, and\n      2) For every contiguous triple of characters (s[i], s[i+1], s[i+2]),\n         all three characters are pairwise distinct.\n\n    The check is purely by character equality; it works for ASCII and Unicode.\n\n    Examples\n    --------\n    >>> is_happy(\"a\")\n    False\n    >>> is_happy(\"aa\")\n    False\n    >>> is_happy(\"abcd\")\n    True\n    >>> is_happy(\"aabb\")\n    False\n    >>> is_happy(\"adb\")\n    True\n    >>> is_happy(\"xyy\")\n    False\n    >>> is_happy(\"abca\")  # \"abc\" and \"bca\" are both triples of distinct chars\n    True\n    \"\"\"\n    # 1) Early exit for strings shorter than 3 characters.\n    if len(s) < 3:\n        return False\n\n    # 2) Slide a window of size 3 across the string.\n    #    For each window (a, b, c), ensure pairwise distinctness.\n    #    We use direct comparisons for O(1) space and speed.\n    #    Equivalent to: len({a, b, c}) == 3, but avoids set allocation.\n    for i in range(len(s) - 2):\n        a, b, c = s[i], s[i + 1], s[i + 2]\n        if not (a != b and a != c and b != c):\n            # Found a triple with a repeated character -> not happy.\n            return False\n\n    # 3) All triples were distinct -> happy string.\n    return True\n\n\n# Optional lightweight self-checks (not executed unless run as a script).\nif __name__ == \"__main__\":\n    tests: Iterable[tuple[str, bool]] = [\n        (\"\", False),\n        (\"a\", False),\n        (\"aa\", False),\n        (\"adb\", True),\n        (\"abc\", True),\n        (\"abcd\", True),\n        (\"aabb\", False),\n        (\"xyy\", False),\n        (\"xxy\", False),\n        (\"xxx\", False),\n        (\"abca\", True),\n        (\"a\ud83d\ude0ab\", True),  # Unicode works the same way\n        (\"a a\", False),  # contains a space; still just chars\n    ]\n    for s, expected in tests:\n        got = is_happy(s)\n        assert got == expected, f\"is_happy({s!r}) -> {got}, expected {expected}\""}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n    \"\"\"You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n    \n    # 1. Check the minimum length condition\n    if len(s) < 3:\n        return False\n        \n    # 2. Iterate through all three-character windows\n    # We iterate up to len(s) - 3 because the indices are i, i+1, i+2\n    for i in range(len(s) - 2):\n        # The three consecutive characters are s[i], s[i+1], s[i+2]\n        char1 = s[i]\n        char2 = s[i+1]\n        char3 = s[i+2]\n        \n        # Check if they are NOT distinct (i.e., any two are equal)\n        if char1 == char2 or char1 == char3 or char2 == char3:\n            # Found a case where 3 consecutive letters are NOT distinct, so the string is NOT happy\n            return False\n            \n    # 3. If the loop completes without returning False, the string is happy\n    return True"}
{"task_id": "HumanEval/80", "completion": "def is_happy(s):\n    \"\"\"\n    Checks if a string is \"happy\".\n    A string is happy if its length is at least 3 and every 3 consecutive\n    letters are distinct.\n\n    Args:\n        s (str): The input string to check.\n\n    Returns:\n        bool: True if the string is happy, False otherwise.\n    \"\"\"\n    # 1. Initial Constraint Validation (Length Check)\n    # A string must have a length of at least 3 to be considered happy.\n    string_length = len(s)\n    if string_length < 3:\n        # If the length is less than 3, it fails the primary condition.\n        return False\n\n    # 2. Iteration Setup (Sliding Window)\n    # We iterate through the string using a sliding window of size 3.\n    # The loop stops at the index i where the triplet (s[i], s[i+1], s[i+2])\n    # is the last possible triplet in the string.\n    # This range is from 0 up to (length - 3). In Python, range(len - 2)\n    # covers indices 0 to len - 3.\n    for i in range(string_length - 2):\n\n        # 3. Consecutive Triplet Check\n        # Extract the current 3 consecutive characters.\n        c1, c2, c3 = s[i], s[i+1], s[i+2]\n\n        # Use a set to efficiently check for distinctness. A set only stores\n        # unique elements. If all three characters are distinct, the set size\n        # will be 3.\n        char_set = {c1, c2, c3}\n\n        # 4. Failure Handling (Early Exit)\n        # If the size of the set is less than 3, it means there is a duplicate\n        # character within the triplet (e.g., 'aa', 'aba', 'xyy').\n        if len(char_set) < 3:\n            # We found a non-happy triplet, so the entire string is not happy.\n            return False\n\n    # 4. Success Handling (Default Return)\n    # If the loop completes without finding any non-happy triplets, it means\n    # every 3 consecutive letters were distinct.\n    return True\n\n# --- Example Usage ---\nif __name__ == \"__main__\":\n    test_cases = {\n        \"a\": False,       # Length < 3\n        \"aa\": False,      # Length < 3\n        \"abcd\": True,     # ('a','b','c') -> 3 distinct, ('b','c','d') -> 3 distinct\n        \"aabb\": False,    # ('a','a','b') -> 2 distinct\n        \"adb\": True,      # ('a','d','b') -> 3 distinct\n        \"xyy\": False,     # ('x','y','y') -> 2 distinct\n        \"abcabc\": True,   # ('a','b','c'), ('b','c','a'), ('c','a','b'), ('a','b','c') all distinct\n        \"aabbaa\": False,  # Fails at ('a','a','b')\n        \"abcdef\": True,\n        \"abacaba\": False, # Fails at ('a','c','a')\n    }\n\n    print(\"--- Happy String Checker Results ---\")\n    for s, expected in test_cases.items():\n        result = is_happy(s)\n        status = \"PASS\" if result == expected else \"FAIL\"\n        print(f\"Input: '{s}' (Length: {len(s)})\")\n        print(f\"  Result: {result}, Expected: {expected} | {status}\")\n    print(\"------------------------------------\")"}
{"task_id": "HumanEval/70", "completion": "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    \"\"\"\n    Return the list in 'strange' order:\n    start with the minimum, then maximum of remaining, then next minimum, etc.\n\n    Examples:\n    >>> strange_sort_list([1, 2, 3, 4])\n    [1, 4, 2, 3]\n    >>> strange_sort_list([5, 5, 5, 5])\n    [5, 5, 5, 5]\n    >>> strange_sort_list([])\n    []\n    \"\"\"\n    n = len(lst)\n    if n <= 1:\n        return lst[:]  # return a shallow copy for consistency\n\n    arr = sorted(lst)\n    res: List[int] = []\n\n    i, j = 0, n - 1\n    take_min = True\n    while i <= j:\n        if take_min:\n            res.append(arr[i])\n            i += 1\n        else:\n            res.append(arr[j])\n            j -= 1\n        take_min = not take_min\n\n    return res\n\n\n# --- quick checks ---\nif __name__ == \"__main__\":\n    assert strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert strange_sort_list([]) == []\n    assert strange_sort_list([7]) == [7]\n    assert strange_sort_list([3, 1, 2]) in ([1, 3, 2],)  # deterministic: [1,3,2]\n    print(\"All tests passed.\")"}
{"task_id": "HumanEval/70", "completion": "from typing import List\n\ndef strange_sort_list(lst: List[int]) -> List[int]:\n    \"\"\"\n    Return the list in \"strange\" order:\n      - repeatedly take the minimum of the remaining elements,\n        then the maximum of the remaining elements, alternating\n        until all elements are consumed.\n\n    The input list is NOT mutated.\n\n    Examples:\n        >>> strange_sort_list([1, 2, 3, 4])\n        [1, 4, 2, 3]\n        >>> strange_sort_list([5, 5, 5, 5])\n        [5, 5, 5, 5]\n        >>> strange_sort_list([])\n        []\n        >>> strange_sort_list([-3, -1, -2, 0, 2])\n        [-3, 2, -2, 0, -1]\n    \"\"\"\n    n = len(lst)\n    # Handle trivial lengths quickly and without mutating the input.\n    if n <= 1:\n        # Return a shallow copy to match \"do not mutate\" and be explicit.\n        return lst[:]\n\n    # Sort a COPY in ascending order; do not mutate the caller's list.\n    arr = sorted(lst)\n\n    # Two-pointer sweep: low -> current minimum, high -> current maximum.\n    low, high = 0, n - 1\n\n    # Start by taking the minimum, then alternate min/max each step.\n    take_low = True\n\n    result: List[int] = []\n\n    # Loop until all elements are consumed.\n    # Invariant: arr[low:high+1] are exactly the remaining elements in ascending order.\n    while low <= high:\n        if take_low:\n            # Take the minimum of the remaining elements.\n            result.append(arr[low])\n            low += 1\n        else:\n            # Take the maximum of the remaining elements.\n            result.append(arr[high])\n            high -= 1\n\n        # Flip the turn for next iteration.\n        take_low = not take_low\n\n    return result\n\n\n# --- Optional lightweight tests (can be removed in production if not needed) ---\nif __name__ == \"__main__\":\n    cases = [\n        ([], []),\n        ([1], [1]),\n        ([1, 2], [1, 2]),\n        ([2, 1], [1, 2]),\n        ([1, 2, 3, 4], [1, 4, 2, 3]),\n        ([5, 5, 5, 5], [5, 5, 5, 5]),\n        ([-3, -1, -2, 0, 2], [-3, 2, -2, 0, -1]),\n        ([9, 7, 7, 1, 3], [1, 9, 3, 7, 7]),\n    ]\n    for inp, expected in cases:\n        out = strange_sort_list(inp)\n        assert out == expected, f\"Input: {inp} | Expected: {expected} | Got: {out}\"\n    print(\"All tests passed.\")"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n\n    # 1. Sort the list to easily access the current minimum and maximum.\n    sorted_lst = sorted(lst)\n\n    # 2. Initialize pointers for the smallest (left) and largest (right) remaining elements.\n    left = 0\n    right = len(sorted_lst) - 1\n    result = []\n\n    # 3. Iterate, alternating between the minimum and maximum remaining values.\n    while left <= right:\n        # Append the current minimum (smallest remaining element)\n        result.append(sorted_lst[left])\n        left += 1\n\n        # Check if there's a maximum remaining element to append next.\n        # This prevents an index error and handles lists of odd length correctly.\n        if left <= right:\n            # Append the current maximum (largest remaining element)\n            result.append(sorted_lst[right])\n            right -= 1\n\n    return result"}
{"task_id": "HumanEval/70", "completion": "def strange_sort_list(lst: list[int]) -> list[int]:\n    '''\n    Given a list of integers, return a new list in \"strange\" order.\n    Strange sorting is achieved by starting with the minimum value, then \n    the maximum of the remaining integers, then the minimum, and so on.\n\n    The original input list remains unchanged.\n\n    Args:\n        lst: The input list of integers.\n\n    Returns:\n        A new list of integers sorted in the strange min-max alternating order.\n    '''\n    \n    # 1. Initialization and Input Handling\n\n    # 1. Handle Edge Case: If the list is empty, return an empty list immediately.\n    if not lst:\n        return []\n\n    # 2. Create Working Copy and Initial Sort: \n    # Sorting the list allows for O(1) retrieval of the current minimum (at index 0)\n    # and the current maximum (at index -1) in each iteration.\n    sorted_list = sorted(lst)\n\n    # 3. Initialize Result List: This will store the output in the strange order.\n    result = []\n\n    # 4. Initialize Toggle Flag: \n    # True indicates the next element to pick is the minimum (pop from the start).\n    # False indicates the next element to pick is the maximum (pop from the end).\n    is_min_turn = True\n\n    # 2. Core Alternating Selection Algorithm\n\n    # 1. Iterative Loop: Continue until the working list is empty.\n    while sorted_list:\n        if is_min_turn:\n            # 2. Minimum Selection Phase\n            \n            # Select and remove the minimum element (always at the start of the sorted list).\n            # pop(0) has O(N) complexity but is necessary here for the min/max strategy.\n            element = sorted_list.pop(0)\n            \n            # Append to the result list.\n            result.append(element)\n            \n            # Toggle Flag: Prepare for the maximum selection phase.\n            is_min_turn = False\n        else:\n            # 3. Maximum Selection Phase\n            \n            # Check for Remaining Element: This condition handles the case where the list\n            # had an odd number of elements and the last element was already popped in \n            # the minimum phase. If this check is omitted, an IndexError might occur.\n            if sorted_list:\n                # Select and remove the maximum element (always at the end of the sorted list).\n                # pop(-1) is an efficient O(1) operation.\n                element = sorted_list.pop(-1)\n                \n                # Append to the result list.\n                result.append(element)\n            \n            # Toggle Flag: Prepare for the minimum selection phase for the next iteration.\n            is_min_turn = True\n\n    # 3. Final Output\n\n    # 1. Return: Return the final list in the strange sort order.\n    return result\n\n# --- Example Usage (Optional for testing) ---\n# print(f\"Test 1: [1, 2, 3, 4] -> {strange_sort_list([1, 2, 3, 4])}\")\n# # Expected: [1, 4, 2, 3]\n\n# print(f\"Test 2: [5, 5, 5, 5] -> {strange_sort_list([5, 5, 5, 5])}\")\n# # Expected: [5, 5, 5, 5]\n\n# print(f\"Test 3: [] -> {strange_sort_list([])}\")\n# # Expected: []\n\n# print(f\"Test 4: [10, 2, 8, 4, 6] -> {strange_sort_list([10, 2, 8, 4, 6])}\")\n# # Sorted: [2, 4, 6, 8, 10]\n# # Expected: [2, 10, 4, 8, 6]"}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n\n    Args:\n        n (int): Positive integer (n >= 1).\n\n    Returns:\n        int: The sum 1 + 2 + ... + n.\n\n    Raises:\n        TypeError: If n is not an integer.\n        ValueError: If n < 1.\n\n    Examples:\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 1:\n        raise ValueError(\"n must be >= 1 to sum from 1 to n\")\n\n    # Arithmetic series formula; use integer math to avoid floats.\n    return n * (n + 1) // 2"}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int) -> int:\n    \"\"\"\n    sum_to_n is a function that returns the sum of all integers from 1 to n (inclusive).\n\n    The function uses the arithmetic series formula n*(n+1)/2 for O(1) computation time.\n\n    Parameters\n    ----------\n    n : int\n        A non-negative integer representing the upper bound of the sum.\n\n    Returns\n    -------\n    int\n        The sum of all integers from 1 to n (inclusive). Returns 0 if n == 0.\n\n    Raises\n    ------\n    TypeError\n        If n is not an integer (or if it\u2019s a boolean).\n    ValueError\n        If n is negative.\n\n    Examples\n    --------\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    >>> sum_to_n(0)\n    0\n    \"\"\"\n\n    # --- Step 1: Input validation ---\n    # Disallow boolean since bool is a subclass of int but semantically not valid here.\n    if isinstance(n, bool):\n        raise TypeError(\"Input must be an integer, not a boolean.\")\n\n    # Ensure the input is an integer\n    if not isinstance(n, int):\n        raise TypeError(f\"Input must be an integer, got {type(n).__name__} instead.\")\n\n    # Negative values are not allowed since sum from 1 to n is undefined for n < 0\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # --- Step 2: Handle base case ---\n    if n == 0:\n        return 0\n\n    # --- Step 3: Compute using arithmetic series formula ---\n    # Use integer arithmetic carefully to avoid unnecessary large intermediate values\n    if n % 2 == 0:\n        # If n is even, divide n by 2 first\n        total = (n // 2) * (n + 1)\n    else:\n        # If n is odd, divide (n + 1) by 2 first\n        total = n * ((n + 1) // 2)\n\n    # --- Step 4: Return the computed sum ---\n    return total"}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    # Use the mathematical formula for the sum of the first n positive integers: n * (n + 1) / 2.\n    # The result is guaranteed to be an integer, so integer division (//) can be used,\n    # or simple multiplication followed by standard division and type conversion if n can be very large.\n    # For standard integer inputs, a simple calculation suffices.\n    return n * (n + 1) // 2"}
{"task_id": "HumanEval/60", "completion": "def sum_to_n(n: int) -> int:\n    \"\"\"\n    Calculates the sum of all positive integers from 1 up to n using Gauss's formula.\n\n    This implementation uses the O(1) arithmetic series formula: n * (n + 1) / 2.\n\n    Args:\n        n: The upper bound integer. \n\n    Returns:\n        The sum of integers from 1 to n. Returns 0 if n is less than 1.\n\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    >>> sum_to_n(0)\n    0\n    \"\"\"\n    \n    # --- Input Validation and Constraints (Plan Step 3) ---\n    # The function is defined for summing positive integers (1 to n).\n    # If n is less than 1 (0 or negative), the sum of the series is \n    # considered 0, representing the sum over an empty set of positive integers.\n    if n < 1:\n        return 0\n\n    # --- Core Logic (Plan Steps 1, 2, 4) ---\n    # Calculate the sum using the direct mathematical formula (O(1) complexity):\n    # S = n * (n + 1) / 2\n    \n    # 1. Calculate the product n * (n + 1).\n    # 2. Perform integer division (//) by 2. This is crucial because n * (n + 1) \n    #    is always an even number, and integer division guarantees the result \n    #    remains an integer, fulfilling the required return type.\n    result = (n * (n + 1)) // 2\n\n    # --- Return Value (Plan Step 5) ---\n    return result\n\nif __name__ == '__main__':\n    # Executes the included doctests to verify functionality\n    import doctest\n    doctest.testmod()\n    \n    # Example usage\n    print(f\"Sum up to 5: {sum_to_n(5)}\")\n    print(f\"Sum up to 30: {sum_to_n(30)}\")\n    print(f\"Sum up to 100: {sum_to_n(100)}\")\n    print(f\"Sum up to -5 (should be 0): {sum_to_n(-5)}\")"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str):\n    \"\"\"\n    Takes a string encoded with encode_shift (lowercase a-z) and returns the decoded string.\n    \"\"\"\n    return \"\".join(chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s)"}
{"task_id": "HumanEval/50", "completion": "def decode_shift(s: str) -> str:\n    \"\"\"\n    Takes as input a string encoded with `encode_shift` and returns the decoded string.\n    This function reverses the Caesar cipher with a shift of +5 applied in `encode_shift`.\n\n    Each lowercase letter ('a' to 'z') is shifted backward by 5 positions in the alphabet,\n    wrapping around from 'a' back to 'z' as needed. Non-lowercase characters are preserved\n    unchanged for safety and readability.\n\n    Example:\n    >>> encode_shift(\"hello\")\n    'mjqqt'\n    >>> decode_shift(\"mjqqt\")\n    'hello'\n    >>> decode_shift(encode_shift(\"abc xyz!\"))\n    'abc xyz!'\n    >>> decode_shift(\"\")\n    ''\n    \"\"\"\n\n    # --- Step 1: Input validation ---\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string.\")\n\n    # --- Step 2: Initialize output list ---\n    decoded_chars = []\n\n    # --- Step 3: Iterate through each character ---\n    for ch in s:\n        # Check if character is lowercase alphabetic\n        if 'a' <= ch <= 'z':\n            # Convert to index 0\u201325\n            index = ord(ch) - ord('a')\n\n            # Shift backward by 5, with modulo 26 to wrap around\n            new_index = (index - 5) % 26\n\n            # Convert back to character\n            decoded_char = chr(new_index + ord('a'))\n            decoded_chars.append(decoded_char)\n        else:\n            # Leave non-lowercase characters unchanged\n            decoded_chars.append(ch)\n\n    # --- Step 4: Combine list of characters into final string ---\n    return \"\".join(decoded_chars)"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    # The encoding is a +5 shift (Caesar cipher). To decode, we apply a -5 shift.\n    # The logic is:\n    # 1. Convert the encoded character's ASCII value (ord(ch)) to its 0-indexed alphabet position\n    #    relative to 'a': ord(ch) - ord(\"a\").\n    # 2. Subtract the shift value (5) to reverse the encoding.\n    # 3. Apply the modulo 26 to handle wrap-around (e.g., 'a' - 5 = 'v').\n    # 4. Add ord(\"a\") back to get the ASCII value of the decoded character.\n    # 5. Convert the ASCII value back to a character (chr).\n    return \"\".join([chr(((ord(ch) - ord(\"a\") - 5) % 26) + ord(\"a\")) for ch in s])"}
{"task_id": "HumanEval/50", "completion": "def encode_shift(s: str):\n    \"\"\"\n    Returns encoded string by shifting every lowercase character by 5 in the alphabet.\n    \n    The encoding process:\n    1. Get the ASCII value of the character (ord(ch)).\n    2. Subtract ord('a') to get a 0-indexed position (0-25).\n    3. Add 5 for the forward shift.\n    4. Apply modulo 26 for wrap-around (z -> e).\n    5. Add ord('a') back to convert the position back to the character's ASCII code.\n    \"\"\"\n    # Note: This implementation assumes the input 's' contains only lowercase 'a'-'z'.\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    Takes as input a string encoded with the encode_shift function (a +5 Caesar cipher). \n    Returns the original decoded string by applying an inverse -5 shift.\n    \n    The decoding process applies the inverse modular arithmetic:\n    1. Convert the character to its 0-indexed position (ord(ch) - ord('a')).\n    2. Subtract the shift amount (5).\n    3. Apply modulo 26 to ensure proper wrap-around for negative results \n       (e.g., 'e' -> 'z' is handled by -1 % 26 == 25 in Python).\n    4. Add ord('a') back to get the ASCII value of the original character.\n    5. Convert the ASCII value back to a character (chr()).\n    \"\"\"\n    \n    # We use a list comprehension for efficient, one-line iteration and transformation.\n    return \"\".join([\n        chr(((ord(ch) - ord(\"a\") - 5) % 26) + ord(\"a\")) \n        for ch in s\n    ])\n\n# Example Usage and Verification:\nif __name__ == '__main__':\n    original_string = \"hello\"\n    \n    # 1. Encoding\n    encoded_string = encode_shift(original_string)\n    print(f\"Original String: {original_string}\")\n    print(f\"Encoded String (Shift +5): {encoded_string}\") # Should be 'mjqqt'\n    \n    # 2. Decoding\n    decoded_string = decode_shift(encoded_string)\n    print(f\"Decoded String (Shift -5): {decoded_string}\") # Should be 'hello'\n\n    # Example with wrap-around ('a' -> 'f', 'z' -> 'e', 'b' -> 'g')\n    wrap_test_original = \"abz\"\n    wrap_test_encoded = encode_shift(wrap_test_original)\n    print(f\"\\nWrap Test Original: {wrap_test_original}\") # 'abz'\n    print(f\"Wrap Test Encoded: {wrap_test_encoded}\") # 'fge' (a+5=f, b+5=g, z+5=e)\n\n    wrap_test_decoded = decode_shift(wrap_test_encoded)\n    print(f\"Wrap Test Decoded: {wrap_test_decoded}\") # 'abz'"}
{"task_id": "HumanEval/40", "completion": "from typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    Return True if there exist three (index-)distinct elements in `l` whose sum is zero.\n    Elements may have the same value as long as they are from different indices (e.g., [0,0,0] -> True).\n\n    Examples:\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    n = len(l)\n    if n < 3:\n        return False\n\n    nums = sorted(l)  # work on a sorted copy; do not mutate caller's list\n\n    for i in range(n - 2):\n        # Small optimization: avoid repeating the same anchor value\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n\n        target = -nums[i]\n        lo, hi = i + 1, n - 1\n\n        while lo < hi:\n            s = nums[lo] + nums[hi]\n            if s == target:\n                return True  # Found nums[i] + nums[lo] + nums[hi] == 0\n            elif s < target:\n                lo += 1\n            else:\n                hi -= 1\n\n    return False"}
{"task_id": "HumanEval/40", "completion": "from typing import List\n\ndef triples_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    Return True iff there exist three distinct elements in the list whose sum is zero.\n\n    This implementation follows the classic \"sort + two-pointer\" 3-sum pattern:\n    - Sort the array (enables pruning and two-pointer sweeps)\n    - Fix one value a[i], then scan the remaining range with two pointers (left, right)\n    - Early-exit on the first valid triple; otherwise return False after exhaustion\n\n    The indices i < left < right are always distinct, so distinctness is guaranteed.\n\n    Args:\n        l: List of integers (may contain negatives, zeros, positives, and duplicates).\n\n    Returns:\n        True if a triple summing to zero exists; False otherwise.\n\n    Complexity:\n        Time  : O(n^2) in the worst case (sorting is O(n log n), dominated by the scan).\n        Space : O(n) due to making a sorted copy (keeps the input list unmodified).\n\n    Examples (doctests):\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    >>> triples_sum_to_zero([0, 0, 0])\n    True\n    >>> triples_sum_to_zero([-1, -1, 2])\n    True\n    \"\"\"\n\n    # Fast-fail: fewer than 3 items cannot form a triple.\n    if len(l) < 3:\n        return False\n\n    # Use a *copy* to avoid mutating the caller's list.\n    a = sorted(l)\n    n = len(a)\n\n    # Iterate each index as the fixed element of the triple.\n    for i in range(n - 2):\n        x = a[i]\n\n        # Pruning: if the fixed value is > 0, all following values are >= x (sorted),\n        # so any sum x + ... + ... will be > 0 and cannot reach 0.\n        if x > 0:\n            return False\n\n        # Optional optimization: skip duplicate fixed values to reduce redundant scans.\n        if i > 0 and a[i] == a[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n        while left < right:\n            s = x + a[left] + a[right]\n            if s == 0:\n                # Found a valid triple; existence is sufficient.\n                return True\n            if s < 0:\n                # Sum too small; move left forward to increase the total.\n                left += 1\n                # Optional duplicate-skip on the left pointer.\n                while left < right and a[left] == a[left - 1]:\n                    left += 1\n            else:\n                # s > 0: Sum too large; move right backward to decrease the total.\n                right -= 1\n                # Optional duplicate-skip on the right pointer.\n                while left < right and a[right] == a[right + 1]:\n                    right -= 1\n\n    # Exhausted all candidates without finding any triple.\n    return False"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n    \"\"\"\n    n = len(l)\n    \n    # Check if the list has at least three elements\n    if n < 3:\n        return False\n\n    # 1. Sort the list (O(N log N))\n    l.sort()\n\n    # 2. Iterate through all possible first elements (O(N^2) total)\n    for i in range(n - 2):\n        # Optimization: Skip duplicates for the first element\n        # This prevents redundant calculations but is not strictly necessary\n        # for correctness in this version (it's mainly for *finding all* triplets)\n        # However, it doesn't hurt.\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n\n        # 3. Two-pointer approach for the remaining two elements\n        target = -l[i]\n        left_ptr = i + 1\n        right_ptr = n - 1\n\n        while left_ptr < right_ptr:\n            current_sum = l[left_ptr] + l[right_ptr]\n\n            if current_sum == target:\n                # Found a triplet: l[i] + l[left_ptr] + l[right_ptr] == 0\n                return True\n            \n            elif current_sum < target:\n                # Need a larger sum, move the left pointer right\n                left_ptr += 1\n            \n            else: # current_sum > target\n                # Need a smaller sum, move the right pointer left\n                right_ptr -= 1\n\n    # 4. If no triplet was found after checking all possibilities\n    return False\n\n# Example Usage (Doctests from the prompt):\n# print(triples_sum_to_zero([1, 3, 5, 0]))    # False\n# print(triples_sum_to_zero([1, 3, -2, 1]))   # True (1 + 1 + (-2) = 0)\n# print(triples_sum_to_zero([1, 2, 3, 7]))    # False\n# print(triples_sum_to_zero([2, 4, -5, 3, 9, 7])) # True (2 + 3 + (-5) = 0)\n# print(triples_sum_to_zero([1]))             # False"}
{"task_id": "HumanEval/40", "completion": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    It returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    This function uses the sorted Two-Pointer technique for an efficient O(N^2) time complexity.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n\n    # Phase 1: Pre-processing and Edge Cases\n\n    # 1. Input Validation/Edge Cases: If the list has fewer than 3 elements, \n    # a triplet cannot be formed.\n    if len(l) < 3:\n        return False\n\n    # 2. Sorting: Sort the list. This step is O(N log N) and is crucial \n    # for the O(N) efficiency of the subsequent Two-Pointer search.\n    l.sort()\n\n    N = len(l)\n\n    # Phase 2: Core Logic (O(N^2) Two-Pointer Search)\n\n    # 3. Main Loop Initialization: Iterate through the list, fixing the first element (l[i]).\n    # We only need to iterate up to N - 2, as we need at least two elements remaining \n    # for the 'left' and 'right' pointers.\n    for i in range(N - 2):\n        # Calculate the required target sum for the remaining two elements: target = 0 - l[i].\n        target = 0 - l[i]\n\n        # 4. Two-Pointer Setup (Inside the Main Loop):\n        # 'left' starts immediately after 'i'.\n        left = i + 1\n        # 'right' starts at the end of the list.\n        right = N - 1\n\n        # 5. Inner Search Loop: Perform the two-pointer search on the remaining subarray.\n        # Continues as long as the pointers have not crossed.\n        while left < right:\n            # 6. Sum Calculation and Decision:\n            current_sum = l[left] + l[right]\n\n            # Case A (Target Found): If the sum of the two pointers equals the target,\n            # we have found a triplet that sums to zero.\n            if current_sum == target:\n                return True\n\n            # Case B (Sum Too Small): If the sum is less than the target, we need \n            # a larger sum. Move the 'left' pointer to a larger value.\n            elif current_sum < target:\n                left += 1\n\n            # Case C (Sum Too Large): If the sum is greater than the target, we need\n            # a smaller sum. Move the 'right' pointer to a smaller value.\n            else: # current_sum > target\n                right -= 1\n\n    # Phase 3: Final Outcome\n\n    # 7. Exhaustive Search Conclusion: If the outer loop completes without\n    # finding any triplet, return False.\n    return False\n\n# Example usage (Optional, but useful for testing):\n# print(triples_sum_to_zero([1, 3, 5, 0])) # Expected: False\n# print(triples_sum_to_zero([1, 3, -2, 1])) # Expected: True\n# print(triples_sum_to_zero([2, 4, -5, 3, 9, 7])) # Expected: True"}
{"task_id": "HumanEval/30", "completion": "from typing import List\n\ndef get_positive(l: List[int]) -> List[int]:\n    \"\"\"Return only positive numbers in the list, preserving order.\n\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    # Keep numbers strictly greater than 0; 0 is not considered positive per examples.\n    return [x for x in l if x > 0]"}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list) -> list:\n    \"\"\"\n    Return only positive numbers (strictly greater than zero) from the list.\n\n    This function preserves the original order and includes duplicates.\n    Zero and negative numbers are excluded.\n\n    Examples:\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    >>> get_positive([])\n    []\n    >>> get_positive([0, -1])\n    []\n    \"\"\"\n\n    # Initialize an empty list to store the positive numbers\n    positives = []\n\n    # Iterate through each element in the input list\n    for x in l:\n        # Check if the element is strictly greater than zero\n        # Note: 0 is not included; True counts as 1 (positive) by Python semantics.\n        if x > 0:\n            positives.append(x)\n\n    # Return the list containing only positive numbers\n    return positives"}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list) -> list:\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [number for number in l if number > 0]"}
{"task_id": "HumanEval/30", "completion": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n\n    This function iterates through the input list and filters out any number\n    that is not strictly greater than zero. Zero and negative numbers are excluded.\n\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    # Implementation Step 2, 3, 4, 5: Core Logic via List Comprehension\n    # This technique iterates through the input list 'l' and efficiently constructs\n    # a new list based on a filtering condition, adhering to the plan's strategy.\n\n    # Iteration: for number in l\n    # Filtering Condition: if number > 0 (strictly positive)\n    # Expression: number (the element itself is included if the condition is met)\n    positive_numbers = [number for number in l if number > 0]\n\n    # Implementation Step 6: Return the result.\n    # The new list contains only the elements that satisfied the positive constraint.\n    return positive_numbers\n\n# Example usage and verification\nif __name__ == '__main__':\n    # A small demonstration to ensure the function works as expected\n    test_cases = [\n        ([-1, 2, -4, 5, 6], \"Example 1\"),\n        ([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], \"Example 2\"),\n        ([-10, -5, -1, 0], \"Only negatives and zero\"),\n        ([1, 5, 10], \"All positives\"),\n        ([], \"Empty list\")\n    ]\n\n    print(\"--- Running get_positive tests ---\")\n    for input_list, label in test_cases:\n        result = get_positive(input_list)\n        print(f\"Test: {label}\")\n        print(f\"  Input: {input_list}\")\n        print(f\"  Output: {result}\")\n        print(\"-\" * 20)\n\n    # Optional: Run doctests for formal verification of examples in the docstring\n    import doctest\n    doctest.testmod(verbose=False)"}
