{"task_id": "HumanEval/90", "completion": "from typing import Iterable, Optional\nimport math\n\ndef next_smallest(lst: Iterable[int]) -> Optional[int]:\n    \"\"\"\n    Return the second smallest *distinct* integer in `lst`.\n    If there is no such element (e.g., list too short or all values equal), return None.\n\n    The function does not mutate `lst` and operates in a single pass with O(1) extra space.\n\n    Definitions:\n    - Let `m1` be the smallest distinct value.\n    - Let `m2` be the smallest distinct value strictly greater than `m1`.\n    - Return `m2` if it exists; else return None.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    >>> next_smallest([1, 1])\n    >>> next_smallest([2, 2, 3])\n    3\n    >>> next_smallest([-1, -5, -5, -2])\n    -2\n\n    Complexity:\n    - Time: O(n) for n = len(lst), single pass\n    - Space: O(1) auxiliary\n    \"\"\"\n\n    # Sentinels representing +\u221e to initialize the two minima.\n    # Using float('inf') keeps comparisons valid against ints in Python.\n    first = math.inf   # smallest distinct value seen so far\n    second = math.inf  # second smallest distinct value (> first)\n\n    # Iterate once and maintain the two minima with strict ordering.\n    for x in lst:\n        # If type robustness is desired, uncomment:\n        # if not isinstance(x, int):\n        #     raise TypeError(f\"All elements must be int, got {type(x).__name__}\")\n\n        if x < first:\n            # New global minimum found: demote previous `first` to `second`\n            second = first\n            first = x\n        elif first < x < second:\n            # x is strictly greater than `first` but smaller than current `second`\n            second = x\n        # else: ignore (covers x == first and x >= second)\n\n    # If `second` was never updated to a finite number, no valid second minimum exists.\n    return None if second is math.inf else int(second)\n\n\n# ---------------------------\n# Basic self-checks (optional)\n# ---------------------------\nif __name__ == \"__main__\":\n    tests = [\n        ([1, 2, 3, 4, 5], 2),\n        ([5, 1, 4, 3, 2], 2),\n        ([], None),\n        ([1, 1], None),\n        ([2], None),\n        ([2, 2, 3], 3),\n        ([3, 2, 2], 3),\n        ([2, 3, 2, 4, 4, 5], 3),\n        ([-1, -5, -5, -2], -2),\n        ([7, 7, 7, 7], None),\n        ([0, 1], 1),\n        ([-10, -10, -9], -9),\n        ([5, 1, 1, 1], 5),\n    ]\n\n    for arr, expected in tests:\n        result = next_smallest(arr)\n        assert result == expected, f\"next_smallest({arr}) -> {result}, expected {expected}\"\n    print(\"All tests passed.\")"}
